module exec_block #(parameter WIDTH=8,
                    parameter MAX_CYCLES=4
                   )(input logic clk,rst_n,start,sel,
                     input logic [1:0] op,
                     input logic [WIDTH-1:0] data_a,
                     input logic [WIDTH-1:0] data_b,
                     output logic [WIDTH-1:0] result,
                     output logic done);
  
  // CONTROL
  logic load_en, exec_en, store_en, exec_done;
  
  exec_fsm fsm1(.clk(clk),.rst_n(rst_n),.start(start),.exec_done(exec_done),.load_en(load_en),.exec_en(exec_en),.store_en(store_en),.done(done));
  
  // DATAPATH
  logic [WIDTH-1:0] a_q,b_q,alu_b,alu_y,exec_q;
  
  reg_n #(.WIDTH(WIDTH)) reg_a(.clk(clk),.rst_n(rst_n),.en(load_en),.d(data_a),.q(a_q));
  reg_n #(.WIDTH(WIDTH)) reg_b(.clk(clk),.rst_n(rst_n),.en(load_en),.d(data_b),.q(b_q));
  
  `ifdef ENABLE_ACCUM
  mux2 #(.WIDTH(WIDTH)) op_mux(.a(b_q),.b(exec_q),.sel(sel),.y(alu_b));
  `else
  assign alu_b=b_q;
  `endif
  
  param_alu #(.WIDTH(WIDTH)) alu1(.a(a_q),.b(alu_b),.sel(op),.y(alu_y));
  
  reg_n #(.WIDTH(WIDTH)) exec_reg(.clk(clk),.rst_n(rst_n),.en(exec_en),.d(alu_y),.q(exec_q));
  
  `ifdef ENABLE_MULTI_CYCLE
  logic [$clog2(MAX_CYCLES)-1:0] cycle_cnt;
  
  counter #(.WIDTH($clog2(MAX_CYCLES))) cnt(.clk(clk),.rst_n(rst_n),.en(exec_en),.count(cycle_cnt));
  
  assign exec_done = (cycle_cnt == MAX_CYCLES-1);
  
  `else
  assign exec_done=1'b1;
  
  `endif
  
  reg_n #(.WIDTH(WIDTH)) out_reg(.clk(clk),.rst_n(rst_n),.en(store_en),.d(exec_q),.q(result));
  
endmodule